<script src="https://unpkg.com/mammoth@1.7.0/mammoth.browser.min.js"></script>
<script>
  const $ = id => document.getElementById(id);
  const openaiKeyEl=$("openaiKey");
  const xiKeyEl=$("xiKey");
  const xiVoiceEl=$("xiVoice");
  const inputEn=$("inputEn");
  const docx=$("docx");
  const translateChk=$("translateChk");
  const ipaChk=$("ipaChk");
  const engine=$("engine");
  const rate=$("rate");
  const rateVal=$("rateVal");
  const prep=$("prep");
  const playFromCurrent=$("playFromCurrent");
  const quickSpeak=$("quickSpeak");
  const testSpeak=$("testSpeak");
  const stopBtn=$("stop");
  const statusEl=$("status");
  const enCol=$("enCol");
  const zhCol=$("zhCol");
  const player=$("player");
  const bar=$("bar");
  const progressWrap=document.querySelector(".progress");
  const charCount=$("charCount");
  const diag=$("diag");

  const themeBtn = $("themeBtn");

  const studyCard = $("studyWidget");
  const btnDetail = $("toggleDetail");
  const btnTimer = $("toggleTimer");
  const kThis = $("kThis");
  const kTotal = $("kTotal");
  const kDay = $("kDay");
  const kWeek = $("kWeek");
  const kMonth = $("kMonth");
  const kYear = $("kYear");

  const LS_KEYS = {
    OPENAI:"openaiKey",
    XI:"xiKey",
    XIVOICE:"xiVoice",
    THEME:"study:theme",
    DAILY:"study:dailySeconds"   // { "YYYY-MM-DD": seconds }
  };

  // è¯»å–å¯†é’¥
  try{
    openaiKeyEl.value=localStorage.getItem(LS_KEYS.OPENAI)||"";
    xiKeyEl.value=localStorage.getItem(LS_KEYS.XI)||"";
    xiVoiceEl.value=localStorage.getItem(LS_KEYS.XIVOICE)||xiVoiceEl.value;
  }catch(e){console.warn("localStorage ä¸å¯ç”¨ï¼š",e);}

  $("saveKeys").addEventListener("click",()=>{
    try{
      const ok=openaiKeyEl.value.trim().replace(/^["']|["']$/g,"");
      const xk=xiKeyEl.value.trim().replace(/^["']|["']$/g,"");
      const xv=xiVoiceEl.value.trim().replace(/^["']|["']$/g,"");
      localStorage.setItem(LS_KEYS.OPENAI,ok);
      localStorage.setItem(LS_KEYS.XI,xk);
      localStorage.setItem(LS_KEYS.XIVOICE,xv);
      openaiKeyEl.value=ok; xiKeyEl.value=xk; xiVoiceEl.value=xv;
      const hint=$("saveHint");
      hint.style.display="block";
      setTimeout(()=>hint.style.display="none",1600);
    }catch(e){ alert("æ— æ³•ä¿å­˜ï¼šæµè§ˆå™¨ç¦æ­¢äº†æœ¬åœ°å­˜å‚¨æˆ–å¤„äºéšç§æ¨¡å¼"); }
  });
  $("clearKeys").addEventListener("click",()=>{
    try{
      localStorage.removeItem(LS_KEYS.OPENAI);
      localStorage.removeItem(LS_KEYS.XI);
      localStorage.removeItem(LS_KEYS.XIVOICE);
      openaiKeyEl.value=""; xiKeyEl.value="";
      const hint=$("saveHint");
      hint.textContent="å·²æ¸…é™¤æœ¬åœ°å¯†é’¥";
      hint.style.display="block";
      setTimeout(()=>{
        hint.textContent="å·²ä¿å­˜åˆ°æœ¬åœ° âœ“";
        hint.style.display="none";
      },1600);
    }catch(e){ alert("æ¸…é™¤å¤±è´¥ï¼š"+e); }
  });

  // ä¸»é¢˜åˆ‡æ¢
  function applyTheme(theme){
    document.body.classList.toggle("dark", theme==="dark");
    themeBtn.textContent = theme==="dark" ? "â˜€ï¸ æµ…è‰²" : "ğŸŒ™ æ·±è‰²";
    localStorage.setItem(LS_KEYS.THEME, theme);
  }
  (function initTheme(){
    const saved = localStorage.getItem(LS_KEYS.THEME);
    const prefersDark = window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches;
    const theme = saved || (prefersDark ? "dark" : "light");
    applyTheme(theme);
  })();
  themeBtn.addEventListener("click",()=>{
    const current = document.body.classList.contains("dark") ? "dark" : "light";
    applyTheme(current==="dark" ? "light" : "dark");
  });

  // å·¥å…·å‡½æ•°
  const clamp=(v,min,max)=>Math.min(max,Math.max(min,v));
  function updateCount(){ charCount.textContent=(inputEn.value||"").length+" chars"; }
  ["input","change","keyup","paste"].forEach(ev=> inputEn.addEventListener(ev,updateCount));
  updateCount();
  rate.addEventListener("input",()=>{rateVal.textContent=Number(rate.value).toFixed(2)+"x";});

  function showDiag(msg){ diag.textContent=msg; diag.style.display="block"; }
  function hideDiag(){ diag.style.display="none"; diag.textContent=""; }

  function ensureVoicesLoaded(timeout=2000){
    return new Promise((resolve)=>{
      const have=()=> speechSynthesis.getVoices().length>0;
      if(have()) return resolve(true);
      const id=setInterval(()=>{
        if(have()){clearInterval(id); resolve(true);}
      },150);
      setTimeout(()=>{clearInterval(id); resolve(true);},timeout);
    });
  }

  // æ‹†å¥ & æ¸²æŸ“
  let EN=[], ZH=[], PH=[], currentIndex=0, isSpeaking=false;

  function splitSentences(txt){
    const cleaned=(txt||"").replace(/\s+/g," ").trim();
    if(!cleaned) return [];
    return cleaned.split(/(?<=[.!?])\s+/).filter(Boolean);
  }

  // è¡Œé«˜å¯¹é½ï¼šä¸­è‹±æ¯ä¸€è¡ŒåŒé«˜
  function syncRowHeights() {
    const ens = enCol.children;
    const zhs = zhCol.children;
    const n = Math.min(ens.length, zhs.length);
    for (let i = 0; i < n; i++) {
      ens[i].style.minHeight = "";
      zhs[i].style.minHeight = "";
    }
    for (let i = 0; i < n; i++) {
      const h = Math.max(ens[i].offsetHeight, zhs[i].offsetHeight);
      ens[i].style.minHeight = h + "px";
      zhs[i].style.minHeight = h + "px";
    }
  }

  function renderCols(){
    enCol.innerHTML=""; zhCol.innerHTML="";
    EN.forEach((s,i)=>{
      const d=document.createElement("div");
      d.className="sent"+(i===currentIndex?" active":"");
      const ipa = PH[i] ? `<div class="ipa">/${PH[i]}/</div>` : "";
      d.innerHTML = `<div>${s}</div>${ipa}`;
      d.dataset.idx=i;
      d.onclick=()=>{highlight(i); speakFrom(i);};
      enCol.appendChild(d);

      const z=document.createElement("div");
      z.className="sent sent-zh"+(i===currentIndex?" active":"");
      z.textContent=ZH[i]||"";
      zhCol.appendChild(z);
    });

    requestAnimationFrame(syncRowHeights);
  }
function highlight(i){
  currentIndex=i;
  [...enCol.children].forEach((el,idx)=> el.classList.toggle("active",idx===i));
  [...zhCol.children].forEach((el,idx)=> el.classList.toggle("active",idx===i));

  enCol.children[i]?.scrollIntoView({behavior:"smooth",block:"center"});
  zhCol.children[i]?.scrollIntoView({behavior:"smooth",block:"center"});

  // â˜… æ¯æ¬¡é«˜äº®å˜åŒ–åï¼Œé‡æ–°åŒæ­¥ä¸­è‹±æ–‡æ¯è¡Œçš„é«˜åº¦
  requestAnimationFrame(syncRowHeights);
}
  // è¯»å– docx
  docx.addEventListener("change",async(e)=>{
    const f=e.target.files?.[0]; if(!f) return;
    const buf=await f.arrayBuffer();
    const {value}=await window.mammoth.extractRawText({arrayBuffer:buf});
    inputEn.value=value.trim(); updateCount();
  });

  // === ç¿»è¯‘ï¼ˆå¸¦ id æ˜ å°„ï¼Œé˜²æ­¢é”™ä½ï¼‰ ===
  async function translateBySentence(arr){
    const n = arr.length;
    if(!translateChk.checked) return new Array(n).fill("");
    const key=openaiKeyEl.value.trim();
    if(!key){
      alert("å¼€å¯äº†è‡ªåŠ¨ç¿»è¯‘ï¼Œè¯·å…ˆå¡«å†™ OpenAI Keyï¼Œæˆ–å…ˆå…³æ‰è‡ªåŠ¨ç¿»è¯‘");
      return new Array(n).fill("");
    }
    statusEl.textContent="æ­£åœ¨é€å¥ç¿»è¯‘â€¦"; hideDiag();

    const items = arr.map((text,id)=>({id,text}));
    const payload = {
      model:"gpt-4o-mini",
      messages:[
        {
          role:"system",
          content:
            "You are a translation engine. Input is JSON {\"items\":[{\"id\":number,\"text\":string}...]}. " +
            "You MUST reply ONLY with JSON of the form {\"items\":[{\"id\":number,\"zh\":string}...]}. " +
            "For each input item, keep the same id and translate text into Simplified Chinese. " +
            "Do not merge, split, drop or reorder ids. No commentary."
        },
        { role:"user", content: JSON.stringify({items}) }
      ],
      temperature:0,
      response_format:{ type:"json_object" }
    };

    try{
      const res = await fetch("https://api.openai.com/v1/chat/completions",{
        method:"POST",
        headers:{
          "Content-Type":"application/json",
          "Authorization":`Bearer ${key}`
        },
        body:JSON.stringify(payload)
      });
      if(!res.ok){
        statusEl.textContent="ç¿»è¯‘å¤±è´¥";
        const txt = await res.text();
        showDiag("ç¿»è¯‘é”™è¯¯ï¼š"+txt);
        return new Array(n).fill("");
      }
      const data = await res.json();
      const raw = data.choices?.[0]?.message?.content || "{}";
      let obj={};
      try{ obj = JSON.parse(raw); }catch(e){}
      const list = Array.isArray(obj.items) ? obj.items : [];
      const map = {};
      list.forEach(it=>{
        if(typeof it.id==="number"){
          const zh = it.zh ?? it.translation ?? it.cn ?? "";
          map[it.id] = String(zh);
        }
      });
      // æŒ‰åŸå§‹é¡ºåºç”Ÿæˆè¾“å‡ºï¼Œç¼ºçš„å°±ç•™ç©ºå­—ç¬¦ä¸²ï¼Œä¸ä¼šæ•´ä½“åç§»
      return arr.map((_,i)=> map[i] || "");
    }catch(e){
      statusEl.textContent="ç¿»è¯‘å¤±è´¥";
      showDiag("ç¿»è¯‘å¼‚å¸¸ï¼š"+(e?.message||e));
      return new Array(n).fill("");
    }finally{
      statusEl.textContent="";
    }
  }

  // === IPAï¼ˆå¸¦ id æ˜ å°„ï¼Œé˜²æ­¢é”™ä½ï¼‰ ===
  async function ipaBySentence(arr){
    const n = arr.length;
    if(!ipaChk.checked) return new Array(n).fill("");
    const key=openaiKeyEl.value.trim();
    if(!key){
      alert("æ˜¾ç¤ºç¾å¼éŸ³æ ‡éœ€è¦ OpenAI Keyï¼ˆæˆ–å…ˆå…³é—­â€œæ˜¾ç¤ºç¾å¼éŸ³æ ‡â€ï¼‰");
      return new Array(n).fill("");
    }
    statusEl.textContent="æ­£åœ¨ç”Ÿæˆç¾å¼éŸ³æ ‡â€¦"; hideDiag();

    const items = arr.map((text,id)=>({id,text}));
    const payload = {
      model:"gpt-4o-mini",
      messages:[
        {
          role:"system",
          content:
            "You are an American English phonetics assistant. Input is JSON {\"items\":[{\"id\":number,\"text\":string}...]}. " +
            "You MUST reply ONLY with JSON {\"items\":[{\"id\":number,\"ipa\":string}...]}. " +
            "For each input item, keep the same id and output the American IPA transcription of text. " +
            "Do not merge, split, drop or reorder ids. Do NOT include slashes around the transcription. No commentary."
        },
        { role:"user", content: JSON.stringify({items}) }
      ],
      temperature:0,
      response_format:{ type:"json_object" }
    };

    try{
      const res = await fetch("https://api.openai.com/v1/chat/completions",{
        method:"POST",
        headers:{
          "Content-Type":"application/json",
          "Authorization":`Bearer ${key}`
        },
        body:JSON.stringify(payload)
      });
      if(!res.ok){
        statusEl.textContent="éŸ³æ ‡ç”Ÿæˆå¤±è´¥";
        const txt = await res.text();
        showDiag("éŸ³æ ‡é”™è¯¯ï¼š"+txt);
        return new Array(n).fill("");
      }
      const data = await res.json();
      const raw = data.choices?.[0]?.message?.content || "{}";
      let obj={};
      try{ obj = JSON.parse(raw); }catch(e){}
      const list = Array.isArray(obj.items) ? obj.items : [];
      const map = {};
      list.forEach(it=>{
        if(typeof it.id==="number"){
          const ipa = it.ipa ?? "";
          map[it.id] = String(ipa);
        }
      });
      return arr.map((_,i)=> map[i] || "");
    }catch(e){
      statusEl.textContent="éŸ³æ ‡ç”Ÿæˆå¤±è´¥";
      showDiag("éŸ³æ ‡å¼‚å¸¸ï¼š"+(e?.message||e));
      return new Array(n).fill("");
    }finally{
      statusEl.textContent="";
    }
  }

  // é¢„å¤„ç†
  prep.addEventListener("click",async()=>{
    const txt=inputEn.value.trim();
    if(!txt){ alert("è¯·å…ˆç²˜è´´è‹±æ–‡å†…å®¹"); return; }
    EN=splitSentences(txt);
    if(EN.length===0){
      alert("æ²¡æœ‰æ£€æµ‹åˆ°å®Œæ•´å¥å­ï¼ˆè¯·æ£€æŸ¥è‹±æ–‡å¥å°¾æ˜¯å¦æœ‰ . ? !ï¼‰");
      return;
    }
    ZH=new Array(EN.length).fill("");
    PH=new Array(EN.length).fill("");
    currentIndex=0;
    renderCols(); highlight(0);
    try{
      ZH=await translateBySentence(EN);
      PH=await ipaBySentence(EN);
      renderCols(); highlight(0);
    }catch(e){console.error(e);}
  });

  // æœ—è¯»ç›¸å…³
  async function speakFrom(start){
    const eng=engine.value;
    if(eng==="browser" && EN.length===0){
      const text=inputEn.value.trim();
      if(!text){ alert("è¯·å…ˆç²˜è´´è‹±æ–‡å†…å®¹"); return; }
      await ensureVoicesLoaded();
      speechSynthesis.cancel();
      const u=new SpeechSynthesisUtterance(text);
      u.lang="en-US"; u.rate=clamp(parseFloat(rate.value),0.6,1.4);
      u.onerror=e=>console.warn("æµè§ˆå™¨æœ—è¯»é”™è¯¯",e);
      speechSynthesis.speak(u);
      return;
    }
    if(!EN.length){
      alert("è¿˜æ²¡æœ‰å¥å­å¯è¯»ï¼Œè¯·å…ˆâ€œæ‹†å¥ & ç¿»è¯‘éŸ³æ ‡â€");
      return;
    }
    if(eng!=="browser"){
      if(eng==="openai" && !openaiKeyEl.value.trim()) return alert("OpenAI æ¨¡å¼éœ€è¦ OpenAI Key");
      if(eng==="eleven" && !xiKeyEl.value.trim()) return alert("ElevenLabs æ¨¡å¼éœ€è¦ ElevenLabs Key");
    }
    isSpeaking=true;
    showProgress(eng!=="browser");
    try{
      if(eng==="browser") await speakBrowserFrom(start);
      else if(eng==="openai") await speakOpenAIFrom(start);
      else await speakElevenFrom(start);
    }catch(err){
      alert("æœ—è¯»å‡ºé”™ï¼š"+(err?.message||err));
    }finally{
      isSpeaking=false;
      showProgress(false);
    }
  }

  async function speakBrowserFrom(start){
    await ensureVoicesLoaded();
    speechSynthesis.cancel();
    for(let i=start;i<EN.length;i++){
      highlight(i);
      const u=new SpeechSynthesisUtterance(EN[i]);
      u.lang="en-US"; u.rate=clamp(parseFloat(rate.value),0.6,1.4);
      await new Promise(res=>{
        u.onend=res; u.onerror=res;
        speechSynthesis.speak(u);
      });
      if(!isSpeaking) break;
    }
  }

  async function speakOpenAIFrom(start){
    const key=openaiKeyEl.value.trim();
    for(let i=start;i<EN.length;i++){
      highlight(i);
      const url=await openaiTts(EN[i],key);
      await play(url);
      setBar(((i-start+1)/(EN.length-start))*100);
      if(!isSpeaking) break;
    }
  }
  async function openaiTts(text,key){
    const res=await fetch("https://api.openai.com/v1/audio/speech",{
      method:"POST",
      headers:{
        "Content-Type":"application/json",
        "Authorization":`Bearer ${key}`
      },
      body:JSON.stringify({
        model:"gpt-4o-mini-tts",
        voice:"alloy",
        input:text,
        format:"mp3"
      })
    });
    if(!res.ok) throw new Error(await res.text());
    const buf=await res.arrayBuffer();
    return URL.createObjectURL(new Blob([buf],{type:"audio/mpeg"}));
  }

  async function speakElevenFrom(start){
    const key=xiKeyEl.value.trim();
    const vid=xiVoiceEl.value.trim();
    for(let i=start;i<EN.length;i++){
      highlight(i);
      const url=await elevenTts(EN[i],key,vid);
      await play(url);
      setBar(((i-start+1)/(EN.length-start))*100);
      if(!isSpeaking) break;
    }
  }
  async function elevenTts(text,key,voiceId){
    const url=`https://api.elevenlabs.io/v1/text-to-speech/${encodeURIComponent(voiceId)}`;
    const res=await fetch(url,{
      method:"POST",
      headers:{
        "xi-api-key":key,
        "Content-Type":"application/json",
        "accept":"audio/mpeg"
      },
      body:JSON.stringify({
        text,
        model_id:"eleven_turbo_v2",
        voice_settings:{stability:0.5,similarity_boost:0.8}
      })
    });
    if(!res.ok) throw new Error(await res.text());
    const buf=await res.arrayBuffer();
    return URL.createObjectURL(new Blob([buf],{type:"audio/mpeg"}));
  }

  function play(url){
    return new Promise((resolve,reject)=>{
      player.src=url;
      player.playbackRate=clamp(parseFloat(rate.value),0.6,1.4);
      player.onended=()=>resolve();
      player.onerror=e=>reject(e);
      player.play().catch(reject);
    });
  }

  stopBtn.addEventListener("click",()=>{
    isSpeaking=false;
    speechSynthesis?.cancel?.();
    player.pause();
  });
  function showProgress(v){
    progressWrap.style.display=v?"block":"none";
    if(!v) setBar(0);
  }
  function setBar(p){ bar.style.width=p+"%"; }

  playFromCurrent.addEventListener("click",()=> speakFrom(currentIndex));
  quickSpeak.addEventListener("click",()=>{
    engine.value="browser";
    speakFrom(0);
  });
  testSpeak.addEventListener("click", async ()=>{
    try{
      await ensureVoicesLoaded();
      speechSynthesis.cancel();
      const u=new SpeechSynthesisUtterance("Hello from your browser! Testing testing.");
      u.lang="en-US"; u.rate=clamp(parseFloat(rate.value),0.6,1.4);
      speechSynthesis.speak(u);
    }catch(e){
      alert("æµ‹è¯•æœ—è¯»å¤±è´¥ï¼š"+(e?.message||e));
    }
  });

  // ==== å­¦ä¹ æ—¶é•¿ç»Ÿè®¡ ====
  function todayStr(d=new Date()){
    const y=d.getFullYear();
    const m=String(d.getMonth()+1).padStart(2,"0");
    const dd=String(d.getDate()).padStart(2,"0");
    return `${y}-${m}-${dd}`;
  }
  function getMonday(d){
    const x=new Date(d);
    const day=(x.getDay()+6)%7; // å‘¨ä¸€=0
    x.setHours(0,0,0,0);
    x.setDate(x.getDate()-day);
    return x;
  }
  function endOfWeek(d){
    const m=getMonday(d);
    const e=new Date(m);
    e.setDate(m.getDate()+6);
    return e;
  }
  function startOfMonth(d){ return new Date(d.getFullYear(), d.getMonth(), 1); }
  function endOfMonth(d){ return new Date(d.getFullYear(), d.getMonth()+1, 0); }
  function startOfYear(d){ return new Date(d.getFullYear(),0,1); }
  function endOfYear(d){ return new Date(d.getFullYear(),11,31); }

  function loadDaily(){
    try{
      const raw=localStorage.getItem(LS_KEYS.DAILY);
      if(!raw) return {};
      const obj=JSON.parse(raw);
      return obj && typeof obj==="object" ? obj : {};
    }catch{ return {}; }
  }
  function saveDaily(map){
    try{ localStorage.setItem(LS_KEYS.DAILY, JSON.stringify(map)); }
    catch(e){ console.warn("ä¿å­˜ç»Ÿè®¡å¤±è´¥",e); }
  }

  function fmtHMS(sec){
    sec=Math.max(0,Math.floor(sec));
    const h=Math.floor(sec/3600);
    const m=Math.floor((sec%3600)/60);
    const s=sec%60;
    return `${String(h).padStart(2,"0")}:${String(m).padStart(2,"0")}:${String(s).padStart(2,"0")}`;
  }
  function fmtHMfromSec(sec){
    sec=Math.max(0,Math.floor(sec));
    const h=Math.floor(sec/3600);
    const m=Math.floor((sec%3600)/60);
    return `${h}å°æ—¶${m}åˆ†é’Ÿ`;
  }
  function minutesStr(sec){
    const m=Math.round(sec/60);
    return `${m}åˆ†é’Ÿ`;
  }

  let daily = loadDaily();
  let sessionSeconds = 0;
  let tickTimer = null;
  let visible = document.visibilityState === "visible";
  let running = true;

  function sumRange(startDate,endDate){
    const s=new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate());
    const e=new Date(endDate.getFullYear(), endDate.getMonth(), endDate.getDate());
    let cur=new Date(s);
    let total=0;
    while(cur<=e){
      total += (daily[todayStr(cur)]||0);
      cur.setDate(cur.getDate()+1);
    }
    return total;
  }
  function totalAll(){
    return Object.values(daily).reduce((a,b)=>a+(+b||0),0);
  }

  function renderStats(){
    const now=new Date();
    kThis.textContent = fmtHMS(sessionSeconds);
    kTotal.textContent = fmtHMfromSec(totalAll());
    kDay.textContent = minutesStr(daily[todayStr(now)]||0);
    kWeek.textContent = minutesStr(sumRange(getMonday(now), endOfWeek(now)));
    kMonth.textContent = minutesStr(sumRange(startOfMonth(now), endOfMonth(now)));
    kYear.textContent = minutesStr(sumRange(startOfYear(now), endOfYear(now)));
  }

  function tick(){
    if(!visible || !running) return;
    sessionSeconds += 1;
    const key=todayStr(new Date());
    daily[key]=(daily[key]||0)+1;
  }

  function setRunning(on){
    running = on;
    btnTimer.textContent = on ? "æš‚åœ" : "å¼€å§‹";
  }

  function startCounting(){
    if(tickTimer) clearInterval(tickTimer);
    tickTimer=setInterval(()=>{
      tick();
      if(sessionSeconds % 2 === 0) renderStats();
      if(sessionSeconds % 10 === 0) saveDaily(daily);
    },1000);
    renderStats();
  }

  document.addEventListener("visibilitychange",()=>{
    visible = document.visibilityState === "visible";
  });
  window.addEventListener("focus",()=>{ visible=true; });
  window.addEventListener("blur",()=>{ visible=false; });
  window.addEventListener("beforeunload",()=>{ saveDaily(daily); });

  btnDetail.addEventListener("click",()=>{
    studyCard.classList.toggle("open");
    btnDetail.textContent = studyCard.classList.contains("open") ? "æ”¶èµ·" : "è¯¦æƒ…";
  });

  btnTimer.addEventListener("click",()=>{
    setRunning(!running);
  });

  // çª—å£å°ºå¯¸å˜åŒ–æ—¶ï¼Œé‡æ–°å¯¹é½ä¸­è‹±æ–‡è¡Œé«˜
  window.addEventListener("resize", () => {
    requestAnimationFrame(syncRowHeights);
  });

  // é»˜è®¤è¿›å…¥é¡µé¢å°±å¼€å§‹è®¡æ—¶
  setRunning(true);
  startCounting();
</script>
